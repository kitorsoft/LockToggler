using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Diagnostics;
using System.Windows.Forms;
using System.Runtime.InteropServices;

//todo: autostart

namespace LockToggler
{
    /// <summary>
    /// This is where all the heavy lifting is done, from registering a
    /// keyboard hook up to handling the ampped keys.
    /// </summary>
    class KeyboardWatcher
    {
        private const int WH_KEYBOARD_LL = 13;
        private const int WM_NULL = 0x0000;

        private const byte KEYEVENTF_KEYDOWN = 0x0;
        private const byte KEYEVENTF_EXTENDEDKEY = 0x1;
        private const byte KEYEVENTF_KEYUP = 0x2;

        private const byte VK_CAPITAL = 0x14;
        private const byte VK_NUMLOCK = 0x90;
        private const byte VK_SCROLL = 0x91;

        private static IntPtr hookID = IntPtr.Zero;

        // make sure sound is onl played once when key has been down for a sufficiently long time
        private static bool soundPlayed = false;

        /// <summary>
        /// Start listening for keyboard events
        /// </summary>
        public static void start()
        {
            hookID = SetHook(HookCallback);
        }

        /// <summary>
        /// Stop listening for keyboard events
        /// </summary>
        public static void stop()
        {
            UnhookWindowsHookEx(hookID);
        }

        /// <summary>
        /// Set proc as keyboard event hook
        /// </summary>
        /// <param name="proc">function to be called for keyboard events</param>
        /// <returns></returns>
        private static IntPtr SetHook(LowLevelKeyboardProc proc)
        {
            using (Process curProcess = Process.GetCurrentProcess())
            using (ProcessModule curModule = curProcess.MainModule)
            {
                return SetWindowsHookEx(WH_KEYBOARD_LL, proc,
                    GetModuleHandle(curModule.ModuleName), 0);
            }
        }

        private delegate IntPtr LowLevelKeyboardProc(int nCode, IntPtr wParam, IntPtr lParam);

        /// <summary>
        /// HandlesKeyDown and KeyUp events for defined keys.
        /// When key has been depressed for configured period of time,
        /// it plays a sound (if so configured) and upon KeyUp send the
        /// key press to the system.
        /// If the configured period of time is less than 0, they key will be ignored
        /// and never reach the system.
        /// </summary>
        /// <param name="nCode">Can be HC_ACTION or HC_NOREMOVE. If less than 0  the hook procedure must pass the message to the CallNextHookEx function without further processing and return the value returned by CallNextHookEx</param>
        /// <param name="wParam">Int32 value that contains they virtual key code</param>
        /// <param name="lParam">Pointer to a struct LowLevelKeyboardInputEvent containing additional information</param>
        /// <returns>1 if the event should no be processed any further by the system, or the result of calling CallNextHookEx, which will call other hooks</returns>
        private static IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
        {
            // get the key
            int wparamTyped = wParam.ToInt32();
            KeyboardState? kbdState = null;
            if (Enum.IsDefined(typeof(KeyboardState), wparamTyped))
            {
                kbdState = (KeyboardState)wparamTyped;
            }

            // get additional information
            object o = Marshal.PtrToStructure(lParam, typeof(LowLevelKeyboardInputEvent));
            LowLevelKeyboardInputEvent p = (LowLevelKeyboardInputEvent)o;
            int vkCode = p.VirtualCode;
            Keys vkKey = (Keys)vkCode;
            LowLevelKeyboardInputEventFlags flags = (LowLevelKeyboardInputEventFlags)p.Flags;

            if (nCode >= 0 && // as per spec, values less than 0 indicate that event should not be processed and CallNextHookEx be called immediately
                (!flags.HasFlag(LowLevelKeyboardInputEventFlags.LLKHF_INJECTED)) && // not injected, e. g.  generated by us
                kbdState != null &&
                (kbdState == KeyboardState.KeyDown || kbdState == KeyboardState.KeyUp) && // valid keyboard state
                KeyMap.dtKeys.Keys.Contains(vkKey) && // handled key
                getKeyDelay(vkKey) != 0) // key has a delay assigned (< 0 means deactivated, 0 means no delay)
            {

                //Debug.WriteLine("Timestamp: " + p.TimeStamp.ToString());
                //Debug.WriteLine("Extra Info: " + p.AdditionalInformation.ToString());
                //Debug.WriteLine("Injected: " + (((p.Flags & 0x00000010) > 0) ? "yes" : "no"));

                if (kbdState == KeyboardState.KeyDown)
                {
                    if (KeyMap.dtKeys[vkKey].started == null)
                    {
                        // remember first time they key was pressed (event will be repeated while it is kept down)
                        KeyMap.dtKeys[vkKey].started = DateTime.Now;
                    }
                    else if (Properties.Settings.Default.playSound &&
                        !soundPlayed &&
                        pressDurationSufficient(KeyMap.dtKeys[vkKey].started, vkKey))
                    {
                        // play a sound when configured delay has been reached
                        Sound.play();
                        // only play once, when the use keeps holding the key down
                        soundPlayed = true;
                    }
                }
                else if (kbdState == KeyboardState.KeyUp)
                {
                    DateTime? started = KeyMap.dtKeys[vkKey].started;
                    // reset time the key was first pressed
                    KeyMap.dtKeys[vkKey].started = null;
                    // reset soun played
                    soundPlayed = false;

                    if (pressDurationSufficient(started, vkKey))
                    {
                        // toggle
                        Debug.WriteLine("toggled");
                        // simulate the key being pressed, will have flag set to LLKHF_INJECTED,
                        // so the event will not be handled by us, othewise the cat would bite its own tail
                        pressKey(vkKey); 
                    }
                }

                // cancel event propagation, aka "eat" event
                return (IntPtr) 1;
            }

            // we did not handle the event, pass it on
            return CallNextHookEx(hookID, nCode, wParam, lParam);
        }

        /// <summary>
        /// checks whether they delay configured for the given key has been reached
        /// </summary>
        /// <param name="started">DateTime when the key was pressed down</param>
        /// <param name="vkKey">the key that was pressed</param>
        /// <returns>true, if configured delay has been reached, false otherwise</returns>
        private static bool pressDurationSufficient(DateTime? started, Keys vkKey)
        {
            bool retVal = false;

            if (started != null)
            {
                // calculate milliseconds since key was pressed
                double ms = DateTime.Now.Subtract((DateTime)started).TotalMilliseconds;
                double delay = getKeyDelay(vkKey);
                if (delay >= 0 && ms >= delay) // -1 means disabled, so delay will never be reached
                {
                    retVal = true;
                }
                else
                {
                    Debug.WriteLine("Too short: " + ms.ToString());
                }
            }

            return retVal;
        }

        /// <summary>
        /// gets the configured delay for a given key
        /// </summary>
        /// <param name="k">key code</param>
        /// <returns>delay in ms</returns>
        private static int getKeyDelay(Keys k)
        {
            int retVal = 0;

            // the corresponding settins is name delayXXX,
            // where XXX is the name of the key as per the Keys enum
            string propertyName = "delay" + k.ToString();
            object o = Properties.Settings.Default[propertyName];
            if(o != null)
            {
                retVal = (int)o;
            }
            return retVal;
        }

        /// <summary>
        /// simulates a key press, i.e. down and up event
        /// </summary>
        /// <param name="key">key code to be pressed</param>
        public static void pressKey(Keys key)
        {
            // todo: key to break code mapping
            byte vk = (byte) key;
            byte breakCode = KeyMap.dtKeys[key].breakCode;

            keybd_event(vk, breakCode, KEYEVENTF_KEYDOWN, (UIntPtr) 0);
            keybd_event(vk, breakCode, KEYEVENTF_KEYUP, (UIntPtr) 0);
        }

        #region dllimports
        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool UnhookWindowsHookEx(IntPtr hhk);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr GetModuleHandle(string lpModuleName);

        [DllImport("user32.dll")]
        static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, UIntPtr dwExtraInfo);
        #endregion

    }
}

